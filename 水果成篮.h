#pragma once
#include<vector>
#include<unordered_map>
using namespace std;
//力扣904
//题目：水果成篮
//题目描述：你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果的类型 。
            //你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：
            //
            //你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。
            //你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
            //一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
            //给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。




//滑动窗口
//在本题中实现滑动窗口，主要确定如下三点：
//
//窗口内是什么？ 窗口就是 已经采摘的树
//
//如何移动窗口的起始位置？ 如果采摘了当前树后，已采摘类型大于2，就得减小窗口，直到已采摘类型变回2
//
//如何移动窗口的结束位置？ 窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。

int totalFruit(vector<int>& fruits) {
    int i = 0, j = 0, maxSum = 0, types = 0;
    unordered_map<int, int> umap;

    //加大窗口
    for (j = 0; j < fruits.size(); j++)
    {
        //如果正在采摘的树是新类型，就将已采摘类型加一
        if ((++umap[fruits[j]]) == 1)
            types++;

        //缩减窗口
        while (types > 2)
        {
            //如果正在删减的树，是已采摘的该类型的最后一棵，就将已采摘类型减一
            if ((--umap[fruits[i]]) == 0)
                types--;
            i++;
        }

        //在已采摘类型不大于2的情况下，统计已采摘数量
        int sum = j - i + 1;
        maxSum = maxSum >= sum ? maxSum : sum;
    }

    return maxSum;
}