#pragma once
#include<vector>
#include<string>
using namespace std;
//题目:数字字符串解码方法总数
//题目描述：一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
//'A' -> "1"
//'B' -> "2"
//...
//'Z' -> "26"
//要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
//"AAJF" ，将消息分组为(1 1 10 6)
//"KJF" ，将消息分组为(11 10 6)
//
//注意，消息不能分组为 (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
//给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
//题目数据保证答案肯定是一个 32 位 的整数。


//思路：一个字符串的解码方法可以由其首位字母与去除首字母后的子字符串共同决定
//      因此，可以先算出去除首字母后的子字符串的解码方法，再来计算本字符串的解码方法
//dp
int numDecodings(string s) {
    int n = s.size();
    if (!n)  return 0;//鲁棒
    vector<int> dp(n + 1, 1);//dp数组，代表以第i位开始的子字符串的解码方法总数
    for (int i = n - 1; i >= 0; i--)//从后向前遍历，使得子字符串慢慢变长
    {
        //i位为0
        if (s[i] == '0')   dp[i] = 0;//则以i位开始的子字符串不可能被解码

        //i位不为1、2
        else if (s[i] != '1' && s[i] != '2') dp[i] = dp[i + 1];//则i位不可能与i+1位结合成为一个字母，以i位开始的子字符串的解码方法总数和以i+1开始的一样

        //i位为1、2
        else if (i == n - 1) dp[i] = dp[i + 1];//i位如果是最后一位，自然不存在第i+1位可以与i位结合

        //i位为1
        else if (s[i] == '1')    dp[i] = dp[i + 1] + dp[i + 2];//则i位肯定可以与i+1位结合（不管i+1位是什么，因为10~19都可以用一个字母解码）
                                                                //以i位开始的子字符串的解码就有两种可能：
                                                                //1)i位不与i+1位结合
                                                                //2)i位与i+1位结合
                                                                
        //i位为2，则要视i+1位具体是什么，进行分情况讨论
        else
        {
            if (s[i + 1] - '0' > 6) dp[i] = dp[i + 1];//i+1位大于6，则i位与i+1位不能结合，因为结合出来的数字无法被解码（27、28、29是无法用字母表示的）
            else if (s[i + 1] != 0)  dp[i] = dp[i + 1] + dp[i + 2];//i+1位小于等于6且大于0，则i位肯定可以与i+1位结合
                                                                    //以i位开始的子字符串的解码就有两种可能：
                                                                    //1)i位不与i+1位结合
                                                                    //2)i位与i+1位结合
            else    dp[i] = dp[i + 2];//i+1位为0，则i位必须与i+1结合从而一起解码，而不可以单独解码
                                        //因为如果i位单独解码，则i+1位的0就得单独解码，但是0是无法被解码的
                                        //所以此时，以i位开始的子字符串的解码只有一种可能：i位与i+1位结合
        }
    }
    //dp[0]就是以第0位开始的子字符串的解码方法总数，换言之就是s字符串的解码方法总数
    return dp[0];
}